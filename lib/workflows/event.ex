defmodule Workflows.Event do
  @moduledoc """
  Events generated by a workflow execution.
  """

  alias Workflows.{Execution, Event}

  @type event :: any()

  @type t ::
          Event.ExecutionStarted.t()
          | Event.ChoiceEntered.t()
          | Event.ChoiceExited.t()
          | Event.FailEntered.t()
          | Event.FailExited.t()
          | Event.MapEntered.t()
          | Event.MapExited.t()
          | Event.MapStarted.t()
          | Event.MapSucceeded.t()
          | Event.MapFailed.t()
          | Event.ParallelEntered.t()
          | Event.ParallelExited.t()
          | Event.ParallelStarted.t()
          | Event.ParallelSucceeded.t()
          | Event.ParallelFailed.t()
          | Event.PassEntered.t()
          | Event.PassExited.t()
          | Event.SucceedEntered.t()
          | Event.SucceedExited.t()
          | Event.TaskEntered.t()
          | Event.TaskExited.t()
          | Event.TaskStarted.t()
          | Event.TaskSucceeded.t()
          | Event.TaskFailed.t()
          | Event.WaitEntered.t()
          | Event.WaitExited.t()
          | Event.WaitStarted.t()
          | Event.WaitSucceeded.t()

  @type maybe :: :no_event | t()

  defstruct [:event, :scope]

  @spec create(event(), Execution.scope()) :: t()
  def create(event, scope) do
    %__MODULE__{
      event: event,
      scope: scope
    }
  end

  def push_scope(event, scope) do
    Map.update(event, :scope, [], fn existing_scope -> [scope | existing_scope] end)
  end

  def pop_scope(event) do
    Map.get_and_update(event, :scope, fn
      [] -> {nil, []}
      [current | scope] -> {current, scope}
    end)
  end
end
